/*   vgm.c - A quick 'n dirty VGM player for the Tektronix 4404 AI Workstation.           The 4404 has a TI 76496 PSG for some reason, and what better way to            put it to use than by playing chiptunes?  Well, that's what I            thought at 2am anyway.                      This program plays VGM files that use the PSG; all other commands            and metadata are ignored.  It also requires the input VGM files be            uncompressed.  Sorry.                      As the timebase for the PSG driver in Uniflex is 1/60th of a second,            PAL files and files that require a different timebase will play back           incorrectly.  Life is hard.                      Multiple files may be played in succession, but in that case the           files will not be looped.                      (c) 2020 j. dersch.  */#include <errno.h>#include <sys/fcntl.h>#include <stdio.h>#define VGM_VERSION 0x8#define VGM_STREAM_START_DEFAULT 0x40#define VGM_STREAM_START_OFFSET 0x34#define VGM_LOOP_OFFSET 0x1cchar readByte(inFile)    FILE* inFile;{    char byte = 0;    if (!fread(&byte, sizeof(char), 1, inFile))    {        printf("Short read in readByte.\n");        exit(1);    }        return byte;}unsigned int readWord(inFile)    FILE* inFile;{    unsigned int word = 0;    if (!fread(&word, sizeof(unsigned int), 1, inFile))    {        printf("Short read in readWord.\n");        exit(1);    }    /* convert to big-endian */    word = ((word & 0x000000ff) << 24) |           ((word & 0x0000ff00) << 8) |           ((word & 0x00ff0000) >> 8) |           ((word & 0xff000000) >> 24);    return word;} char writeByte(outFile, byte)    FILE* outFile;    char byte;{    if (!fwrite(&byte, sizeof(char), 1, outFile))    {        printf("Unable to write byte to output.\n");        exit(1);    }}void playFile(inFile, outFile, loop)    FILE* inFile;    FILE* outFile;    int loop;{                   unsigned char block[256];        unsigned int index = 1;    float wait = 0;           unsigned char command = 0;    int done = 0;    unsigned char version = 0;    long dataOffset = 0;    unsigned int loopOffset = 0;                /* Grab the version of the file so we know where the data begins        We are bad and we just grab the first byte and compare it because       good lord why is this BCD encoded? */        if (fseek(inFile, VGM_VERSION, 0))    {        printf("Could not read version.\n");        return;    }        version = readByte(inFile);        printf("VGM version 1.%x\n", version);     if (version < 0x50)    {        /* Data starts at offset 0x40 */        dataOffset = VGM_STREAM_START_DEFAULT;    }    else    {        /* Start of data is relative offset from 0x34 */        fseek(inFile, VGM_STREAM_START_OFFSET, 0);        dataOffset = readWord(inFile);        dataOffset += VGM_STREAM_START_OFFSET;         }       printf("VGM stream offset 0x%x\n", dataOffset);    fseek(inFile, VGM_LOOP_OFFSET, 0);    loopOffset = readWord(inFile) + VGM_LOOP_OFFSET;     printf("Loop address 0x%x\n", loopOffset);         /* Seek to the start of VGM data stream */    fseek(inFile, dataOffset, 0);         while(!done)    {                command = readByte(inFile);               switch(command)        {            case 0x50:      /* PSG write value -- append the next byte */                if (index > 1 && wait > 0)                {                    block[0] = index - 1;                    block[index] = (wait + 0.5);  /* round  up */                                        fwrite(block, sizeof(char), index + 1, outFile);                    fflush(outFile);  /* force it out now to avoid stutter */                     wait = 0.0;                    index = 1;                    block[0] = 0;                }                                block[index++] = readByte(inFile);                                if (index > sizeof(block) - 1)                {                    printf("Block size exceeded.\n");                    exit(1);                }                break;                            case 0x61:      /* delay in ticks (735 ticks per 1/60th second) */                {                    unsigned char byte0, byte1;                    byte0 = readByte(inFile);                    byte1 = readByte(inFile);                    wait += (float)(byte0 | (byte1 << 8)) / 735.0;                          }                break;                            case 0x62:      /* delay 1/60th of a second */                wait++;                break;            case 0x63:      /* delay 1/50th of a second (not really supported but we'll fake it anyway) */                wait += (6.0 / 5.0);                 break;                            case 0x66:      /* end of data */                if (loopOffset > VGM_LOOP_OFFSET && loop)                {                    /* take the loop */                                        fseek(inFile, loopOffset, 0);                }                else                {                    /* finish */                    done = 1;                }                break;                  }           }  }int main(argc, argv)    int argc;    char **argv;{        FILE* inFile;    FILE* outFile;    unsigned int fileIndex = 0;     printf("Tektronix 4404 VGM Player v0.0\n");        /* Open /dev/sound for output */    outFile = fopen("/dev/sound", "w");        if (!outFile)    {        printf("Could not open /dev/sound for output.\n");        exit(1);    }               /* Initialize tempo to 1/60th of a second */     writeByte(outFile, 0);    writeByte(outFile, 0);    writeByte(outFile, 1);    for(fileIndex = 1; fileIndex < argc; fileIndex++)    {            /* Open the input file */        inFile = fopen(argv[fileIndex], "r");                if (!inFile)        {            printf("Could not open VGM file %s.\n", argv[fileIndex]);            continue;        }        else        {            printf("Playing '%s'.\n", argv[fileIndex]);            playFile(inFile, outFile, argv <= 2);            fclose(inFile);        }           }        fclose(outFile);}